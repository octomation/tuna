---
issue: 53
status: closed
type: feature
labels:
  - "effort: easy"
  - "impact: low"
  - "scope: code"
  - "type: feature"
assignees:
  - kamilsk
milestone: null
projects: []
relationships:
  parent: null
  blocked_by: []
  blocks: []
---

# Implement `tuna plan` command

## Description

The `plan` command creates a `plan.toml` configuration file for an execution session of a specified assistant.

The generated `plan_id` is a UUID v4.

## CLI Interface

```bash
tuna plan <AssistantID> [flags]
  --models, -m      # Comma-separated list of models (default: claude-sonnet-4-20250514)
  --temperature     # Temperature setting (default: 0.7)
  --max-tokens      # Max tokens for response (default: 4096)
```

## Algorithm

1. **Validation**: verify that `<AssistantID>/` directory exists

2. **Generate UUID**: create unique `plan_id`

3. **Compile system prompt**:
   - Read all files from `<AssistantID>/System prompt/`
   - Filter: only `.txt` and `.md` files, ignore hidden files (starting with `.`)
   - Sort alphabetically by filename (e.g., `fragment_001.md`, `fragment_002.md`, ...)
   - Concatenate file contents into a single string, prepending each fragment with a delimiter:
     ```
     --- fragment_001.md ---
     <file content>

     --- fragment_002.md ---
     <file content>
     ```

4. **Collect queries**:
   - Read file list from `<AssistantID>/Input/`
   - Filter: only `.txt` and `.md` files, ignore hidden files (starting with `.`)
   - Generate `[[query]]` entries with `id` field (filename)

5. **Parse models**:
   - Split `--models` by comma into a string array

6. **Generate `plan.toml`**:
   - Create directory `<AssistantID>/Output/<plan_id>/`
   - Write `plan.toml` file with structure:
     ```toml
     plan_id = "<UUID>"
     assistant_id = "<AssistantID>"

     [assistant]
     system_prompt = """
     <compiled prompt>
     """

     [assistant.llm]
     models = ["model1", "model2"]
     max_tokens = 4096
     temperature = 0.7

     [[query]]
     id = "query_001.md"

     [[query]]
     id = "query_002.txt"
     ```

7. **Output**: display path to created file and brief statistics

## Output

- File: `<AssistantID>/Output/<plan_id>/plan.toml`
- Stdout: file path, number of models, number of queries

## File Filtering

For both `Input/` and `System prompt/` directories:
- **Included:** files with `.txt` or `.md` extensions
- **Ignored:** hidden files (starting with `.`), e.g., `.gitkeep`, `.DS_Store`
- **Ignored:** subdirectories (non-recursive traversal)

## Edge Cases

- Assistant directory does not exist → error
- Empty `Input/` folder (after filtering) → warning, but create plan anyway
- Empty `System prompt/` folder (after filtering) → error (system prompt is required)

## Acceptance Criteria

### Structure
- [x] Command creates `<AssistantID>/Output/<plan_id>/plan.toml`
- [x] `plan_id` is a valid UUID v4
- [x] `assistant_id` matches the provided `<AssistantID>` argument

### System Prompt Compilation
- [x] Only `.txt` and `.md` files are included
- [x] Hidden files and subdirectories are ignored
- [x] Files are sorted alphabetically by filename
- [x] Each fragment is prefixed with `--- <filename> ---` delimiter
- [x] Fragments are separated by blank lines

### LLM Configuration
- [x] `models` is an array of strings parsed from `--models` flag
- [x] `max_tokens` matches `--max-tokens` flag value
- [x] `temperature` matches `--temperature` flag value

### Queries
- [x] Only `.txt` and `.md` files generate `[[query]]` entries
- [x] Hidden files and subdirectories are ignored
- [x] `id` field contains the filename (not full path)

### CLI Output
- [x] Prints path to created `plan.toml`
- [x] Prints number of models
- [x] Prints number of queries

### Error Handling
- [x] Returns error if assistant directory does not exist
- [x] Returns error if `System prompt/` directory is empty or missing
- [x] Prints warning but succeeds if `Input/` directory is empty

---

# Plan: Implement `tuna plan` command

## Overview

This plan describes the implementation steps for the `plan` command that creates a `plan.toml` configuration file for an execution session. The stub command already exists in `internal/command/plan.go` and needs to be extended with actual functionality.

## Prerequisites

- Existing stub command in `internal/command/plan.go`
- Package `internal/assistant/` from issue #52 (validation logic)
- Standard library: `os`, `path/filepath`, `sort`, `strings`, `fmt`
- External: `github.com/google/uuid` for UUID v4 generation
- External: `github.com/pelletier/go-toml/v2` (already in go.mod) for TOML generation

## Steps

### 1. Add UUID dependency

```bash
go get github.com/google/uuid
```

### 2. Create file utilities package

**File:** `internal/assistant/files.go`

```go
package assistant

import (
    "os"
    "path/filepath"
    "sort"
    "strings"
)

// FileFilter defines criteria for filtering files.
type FileFilter struct {
    Extensions  []string // e.g., [".txt", ".md"]
    IgnoreHidden bool    // ignore files starting with "."
}

// DefaultFilter returns the standard filter for assistant files.
func DefaultFilter() FileFilter {
    return FileFilter{
        Extensions:   []string{".txt", ".md"},
        IgnoreHidden: true,
    }
}

// ListFiles returns filtered and sorted list of files in a directory.
// Returns only filenames (not full paths), sorted alphabetically.
func ListFiles(dir string, filter FileFilter) ([]string, error) {
    entries, err := os.ReadDir(dir)
    if err != nil {
        return nil, err
    }

    var files []string
    for _, entry := range entries {
        if entry.IsDir() {
            continue
        }

        name := entry.Name()

        // Skip hidden files
        if filter.IgnoreHidden && strings.HasPrefix(name, ".") {
            continue
        }

        // Check extension
        ext := strings.ToLower(filepath.Ext(name))
        matched := false
        for _, allowed := range filter.Extensions {
            if ext == allowed {
                matched = true
                break
            }
        }
        if !matched {
            continue
        }

        files = append(files, name)
    }

    sort.Strings(files)
    return files, nil
}
```

### 3. Create system prompt compiler

**File:** `internal/assistant/prompt.go`

```go
package assistant

import (
    "fmt"
    "os"
    "path/filepath"
    "strings"
)

// CompileSystemPrompt reads and concatenates all prompt fragments.
// Each fragment is prefixed with "--- <filename> ---" delimiter.
func CompileSystemPrompt(assistantDir string) (string, error) {
    promptDir := filepath.Join(assistantDir, "System prompt")

    files, err := ListFiles(promptDir, DefaultFilter())
    if err != nil {
        if os.IsNotExist(err) {
            return "", fmt.Errorf("system prompt directory not found: %s", promptDir)
        }
        return "", fmt.Errorf("failed to read system prompt directory: %w", err)
    }

    if len(files) == 0 {
        return "", fmt.Errorf("system prompt directory is empty: %s", promptDir)
    }

    var builder strings.Builder
    for i, filename := range files {
        if i > 0 {
            builder.WriteString("\n")
        }

        // Write delimiter
        builder.WriteString(fmt.Sprintf("--- %s ---\n", filename))

        // Read and write content
        content, err := os.ReadFile(filepath.Join(promptDir, filename))
        if err != nil {
            return "", fmt.Errorf("failed to read %s: %w", filename, err)
        }
        builder.Write(content)

        // Ensure trailing newline
        if len(content) > 0 && content[len(content)-1] != '\n' {
            builder.WriteString("\n")
        }
    }

    return builder.String(), nil
}
```

### 4. Create plan generator

**File:** `internal/plan/plan.go`

```go
package plan

import (
    "fmt"
    "os"
    "path/filepath"
    "strings"

    "github.com/google/uuid"
    "github.com/pelletier/go-toml/v2"

    "go.octolab.org/toolset/tuna/internal/assistant"
)

// Config holds the plan configuration from CLI flags.
type Config struct {
    Models      []string
    Temperature float64
    MaxTokens   int
}

// Plan represents the generated plan structure.
type Plan struct {
    PlanID      string    `toml:"plan_id"`
    AssistantID string    `toml:"assistant_id"`
    Assistant   Assistant `toml:"assistant"`
    Queries     []Query   `toml:"query"`
}

// Assistant holds assistant configuration.
type Assistant struct {
    SystemPrompt string `toml:"system_prompt,multiline"`
    LLM          LLM    `toml:"llm"`
}

// LLM holds LLM configuration.
type LLM struct {
    Models      []string `toml:"models"`
    MaxTokens   int      `toml:"max_tokens"`
    Temperature float64  `toml:"temperature"`
}

// Query represents an input query entry.
type Query struct {
    ID string `toml:"id"`
}

// Result contains the result of plan generation.
type Result struct {
    PlanPath    string
    PlanID      string
    ModelsCount int
    QueriesCount int
}

// Generate creates a new execution plan for the given assistant.
func Generate(baseDir, assistantID string, cfg Config) (*Result, error) {
    assistantDir := filepath.Join(baseDir, assistantID)

    // Validate assistant directory exists
    if _, err := os.Stat(assistantDir); os.IsNotExist(err) {
        return nil, fmt.Errorf("assistant directory not found: %s", assistantDir)
    }

    // Generate plan ID
    planID := uuid.New().String()

    // Compile system prompt
    systemPrompt, err := assistant.CompileSystemPrompt(assistantDir)
    if err != nil {
        return nil, err
    }

    // Collect queries
    inputDir := filepath.Join(assistantDir, "Input")
    queryFiles, err := assistant.ListFiles(inputDir, assistant.DefaultFilter())
    if err != nil && !os.IsNotExist(err) {
        return nil, fmt.Errorf("failed to read input directory: %w", err)
    }

    queries := make([]Query, len(queryFiles))
    for i, filename := range queryFiles {
        queries[i] = Query{ID: filename}
    }

    // Build plan
    plan := Plan{
        PlanID:      planID,
        AssistantID: assistantID,
        Assistant: Assistant{
            SystemPrompt: systemPrompt,
            LLM: LLM{
                Models:      cfg.Models,
                MaxTokens:   cfg.MaxTokens,
                Temperature: cfg.Temperature,
            },
        },
        Queries: queries,
    }

    // Create output directory
    outputDir := filepath.Join(assistantDir, "Output", planID)
    if err := os.MkdirAll(outputDir, 0755); err != nil {
        return nil, fmt.Errorf("failed to create output directory: %w", err)
    }

    // Write plan.toml
    planPath := filepath.Join(outputDir, "plan.toml")
    data, err := toml.Marshal(plan)
    if err != nil {
        return nil, fmt.Errorf("failed to marshal plan: %w", err)
    }

    if err := os.WriteFile(planPath, data, 0644); err != nil {
        return nil, fmt.Errorf("failed to write plan.toml: %w", err)
    }

    return &Result{
        PlanPath:     planPath,
        PlanID:       planID,
        ModelsCount:  len(cfg.Models),
        QueriesCount: len(queries),
    }, nil
}

// ParseModels splits comma-separated models string into a slice.
func ParseModels(modelsStr string) []string {
    if modelsStr == "" {
        return nil
    }

    parts := strings.Split(modelsStr, ",")
    models := make([]string, 0, len(parts))
    for _, p := range parts {
        if trimmed := strings.TrimSpace(p); trimmed != "" {
            models = append(models, trimmed)
        }
    }
    return models
}
```

### 5. Update plan command

**File:** `internal/command/plan.go`

```go
package command

import (
    "fmt"
    "os"

    "github.com/spf13/cobra"

    "go.octolab.org/toolset/tuna/internal/plan"
)

// Plan returns a cobra.Command to create an execution plan.
func Plan() *cobra.Command {
    var (
        models      string
        temperature float64
        maxTokens   int
    )

    command := cobra.Command{
        Use:   "plan <AssistantID>",
        Short: "Create an execution plan",
        Long: `Plan creates a TOML configuration file that defines an execution session.

The plan includes:
  - Plan ID (UUID v4)
  - Compiled system prompt (from System prompt/ directory)
  - List of input queries (from Input/ directory)
  - Target models and execution parameters

Output: <AssistantID>/Output/<plan_id>/plan.toml`,

        Args: cobra.ExactArgs(1),
        RunE: func(cmd *cobra.Command, args []string) error {
            assistantID := args[0]

            cwd, err := os.Getwd()
            if err != nil {
                return fmt.Errorf("failed to get working directory: %w", err)
            }

            cfg := plan.Config{
                Models:      plan.ParseModels(models),
                Temperature: temperature,
                MaxTokens:   maxTokens,
            }

            result, err := plan.Generate(cwd, assistantID, cfg)
            if err != nil {
                return err
            }

            // Print summary
            cmd.Printf("Plan created: %s\n", result.PlanPath)
            cmd.Printf("  Plan ID: %s\n", result.PlanID)
            cmd.Printf("  Models:  %d\n", result.ModelsCount)
            cmd.Printf("  Queries: %d\n", result.QueriesCount)

            if result.QueriesCount == 0 {
                cmd.Println("\nWarning: No input queries found. Add .txt or .md files to Input/ directory.")
            }

            return nil
        },
    }

    command.Flags().StringVarP(&models, "models", "m", "claude-sonnet-4-20250514", "Comma-separated list of models")
    command.Flags().Float64Var(&temperature, "temperature", 0.7, "Temperature setting")
    command.Flags().IntVar(&maxTokens, "max-tokens", 4096, "Max tokens for response")

    return &command
}
```

### 6. Add unit tests for file utilities

**File:** `internal/assistant/files_test.go`

```go
package assistant

import (
    "os"
    "path/filepath"
    "testing"
)

func TestListFiles(t *testing.T) {
    t.Run("filters and sorts files", func(t *testing.T) {
        tmpDir := t.TempDir()

        // Create test files
        files := []string{
            "b_query.md",
            "a_query.txt",
            ".hidden.md",
            "c_query.md",
            "readme.pdf", // wrong extension
        }
        for _, f := range files {
            os.WriteFile(filepath.Join(tmpDir, f), []byte("test"), 0644)
        }
        os.Mkdir(filepath.Join(tmpDir, "subdir"), 0755)

        result, err := ListFiles(tmpDir, DefaultFilter())
        if err != nil {
            t.Fatalf("ListFiles() error = %v", err)
        }

        expected := []string{"a_query.txt", "b_query.md", "c_query.md"}
        if len(result) != len(expected) {
            t.Fatalf("Expected %d files, got %d: %v", len(expected), len(result), result)
        }
        for i, name := range expected {
            if result[i] != name {
                t.Errorf("Expected %s at index %d, got %s", name, i, result[i])
            }
        }
    })

    t.Run("returns empty slice for empty directory", func(t *testing.T) {
        tmpDir := t.TempDir()

        result, err := ListFiles(tmpDir, DefaultFilter())
        if err != nil {
            t.Fatalf("ListFiles() error = %v", err)
        }
        if len(result) != 0 {
            t.Errorf("Expected empty slice, got %v", result)
        }
    })
}
```

### 7. Add unit tests for prompt compiler

**File:** `internal/assistant/prompt_test.go`

```go
package assistant

import (
    "os"
    "path/filepath"
    "strings"
    "testing"
)

func TestCompileSystemPrompt(t *testing.T) {
    t.Run("compiles fragments in order", func(t *testing.T) {
        tmpDir := t.TempDir()
        promptDir := filepath.Join(tmpDir, "System prompt")
        os.MkdirAll(promptDir, 0755)

        os.WriteFile(filepath.Join(promptDir, "fragment_002.md"), []byte("Second"), 0644)
        os.WriteFile(filepath.Join(promptDir, "fragment_001.md"), []byte("First"), 0644)
        os.WriteFile(filepath.Join(promptDir, ".hidden.md"), []byte("Hidden"), 0644)

        result, err := CompileSystemPrompt(tmpDir)
        if err != nil {
            t.Fatalf("CompileSystemPrompt() error = %v", err)
        }

        if !strings.Contains(result, "--- fragment_001.md ---") {
            t.Error("Expected fragment_001.md delimiter")
        }
        if !strings.Contains(result, "--- fragment_002.md ---") {
            t.Error("Expected fragment_002.md delimiter")
        }
        if strings.Contains(result, "hidden") {
            t.Error("Hidden file should be excluded")
        }

        // Check order: fragment_001 should come before fragment_002
        idx1 := strings.Index(result, "fragment_001")
        idx2 := strings.Index(result, "fragment_002")
        if idx1 > idx2 {
            t.Error("Fragments should be sorted alphabetically")
        }
    })

    t.Run("returns error for empty directory", func(t *testing.T) {
        tmpDir := t.TempDir()
        os.MkdirAll(filepath.Join(tmpDir, "System prompt"), 0755)

        _, err := CompileSystemPrompt(tmpDir)
        if err == nil {
            t.Error("Expected error for empty system prompt directory")
        }
    })

    t.Run("returns error for missing directory", func(t *testing.T) {
        tmpDir := t.TempDir()

        _, err := CompileSystemPrompt(tmpDir)
        if err == nil {
            t.Error("Expected error for missing system prompt directory")
        }
    })
}
```

### 8. Add unit tests for plan generator

**File:** `internal/plan/plan_test.go`

```go
package plan

import (
    "os"
    "path/filepath"
    "strings"
    "testing"
)

func TestGenerate(t *testing.T) {
    t.Run("creates plan successfully", func(t *testing.T) {
        tmpDir := t.TempDir()
        assistantDir := filepath.Join(tmpDir, "test-assistant")

        // Setup assistant structure
        os.MkdirAll(filepath.Join(assistantDir, "Input"), 0755)
        os.MkdirAll(filepath.Join(assistantDir, "Output"), 0755)
        os.MkdirAll(filepath.Join(assistantDir, "System prompt"), 0755)

        os.WriteFile(filepath.Join(assistantDir, "Input", "query.md"), []byte("test query"), 0644)
        os.WriteFile(filepath.Join(assistantDir, "System prompt", "prompt.md"), []byte("test prompt"), 0644)

        cfg := Config{
            Models:      []string{"gpt-4", "claude-3"},
            Temperature: 0.5,
            MaxTokens:   2048,
        }

        result, err := Generate(tmpDir, "test-assistant", cfg)
        if err != nil {
            t.Fatalf("Generate() error = %v", err)
        }

        // Verify plan.toml was created
        if _, err := os.Stat(result.PlanPath); os.IsNotExist(err) {
            t.Error("plan.toml was not created")
        }

        // Verify UUID format
        if len(result.PlanID) != 36 {
            t.Errorf("Invalid UUID format: %s", result.PlanID)
        }

        if result.ModelsCount != 2 {
            t.Errorf("Expected 2 models, got %d", result.ModelsCount)
        }

        if result.QueriesCount != 1 {
            t.Errorf("Expected 1 query, got %d", result.QueriesCount)
        }
    })

    t.Run("fails for missing assistant directory", func(t *testing.T) {
        tmpDir := t.TempDir()

        _, err := Generate(tmpDir, "nonexistent", Config{})
        if err == nil {
            t.Error("Expected error for missing assistant directory")
        }
    })
}

func TestParseModels(t *testing.T) {
    tests := []struct {
        input    string
        expected []string
    }{
        {"gpt-4", []string{"gpt-4"}},
        {"gpt-4,claude-3", []string{"gpt-4", "claude-3"}},
        {"gpt-4, claude-3 , gemini", []string{"gpt-4", "claude-3", "gemini"}},
        {"", nil},
        {"  ,  ,  ", nil},
    }

    for _, tt := range tests {
        t.Run(tt.input, func(t *testing.T) {
            result := ParseModels(tt.input)
            if len(result) != len(tt.expected) {
                t.Errorf("ParseModels(%q) = %v, want %v", tt.input, result, tt.expected)
                return
            }
            for i, v := range tt.expected {
                if result[i] != v {
                    t.Errorf("ParseModels(%q)[%d] = %q, want %q", tt.input, i, result[i], v)
                }
            }
        })
    }
}
```

### 9. Verify implementation

- [x] Run `go get github.com/google/uuid` to add dependency
- [x] Run `go build` to ensure no compilation errors
- [x] Run `go test ./internal/assistant/...` to verify assistant package tests
- [x] Run `go test ./internal/plan/...` to verify plan package tests
- [x] Create test assistant with `tuna init test-assistant`
- [x] Run `tuna plan test-assistant` and verify output
- [x] Verify `plan.toml` structure matches specification
- [x] Test with multiple models: `tuna plan test-assistant -m "gpt-4,claude-3"`
- [x] Test error cases: missing directory, empty system prompt

## File Changes Summary

| File                                 | Action |
|--------------------------------------|--------|
| `go.mod`                             | Modify |
| `go.sum`                             | Modify |
| `internal/assistant/files.go`        | Create |
| `internal/assistant/files_test.go`   | Create |
| `internal/assistant/prompt.go`       | Create |
| `internal/assistant/prompt_test.go`  | Create |
| `internal/plan/plan.go`              | Create |
| `internal/plan/plan_test.go`         | Create |
| `internal/command/plan.go`           | Modify |

## Notes

- UUID v4 is used as specified (not v7 which is time-based)
- TOML marshaling uses `pelletier/go-toml/v2` which is already in dependencies
- File filtering logic is reusable between `plan` and future commands
- The `assistant` package is extended from issue #52, not duplicated
- Warning for empty Input/ is printed but doesn't cause failure
- Error for empty System prompt/ stops execution as specified
