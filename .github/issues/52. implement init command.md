---
issue: 52
status: closed
type: feature
labels:
  - "effort: medium"
  - "impact: medium"
  - "scope: code"
  - "type: feature"
assignees:
  - kamilsk
milestone: null
projects: []
relationships:
  parent: null
  blocked_by: []
  blocks: []
---

# Implement `tuna init` command

## Description

Implement the `init` command that creates a directory structure for a new Assistant.

## Usage

```bash
tuna init <AssistantID>
```

## Expected behavior

The command should create the following directory structure:

```
<AssistantID>/
├── Input/
│   └── example_query.md
├── Output/
│   └── .gitkeep
└── System prompt/
    └── fragment_001.md
```

### File contents

**Input/example_query.md:**
```markdown
# Example Query

Write your user query here.
```

**System prompt/fragment_001.md:**
```markdown
# Fragment 001

Write your system prompt fragment here.
```

**Output/.gitkeep:**
Empty file to preserve the directory in git.

### AssistantID validation

AssistantID must be a valid directory name for the filesystem:
- Must not be empty
- Must not contain: `/ \ : * ? " < > |`
- Must not be `.` or `..`
- Must not exceed 255 characters

### Behavior with existing structure

If the directory already partially exists, the command should **complete the missing parts**:
- Create missing subdirectories (Input/, Output/, System prompt/)
- Create missing template files only if directory is empty
- Skip existing files (do not overwrite)
- Report what was created and what was skipped

## Acceptance criteria

- [x] Command validates that AssistantID is provided
- [x] Command validates AssistantID against filesystem naming rules
- [x] Command creates all required directories
- [x] Command creates template files with placeholder content
- [x] Command completes partial structure if directory exists
- [x] Command skips existing files without overwriting
- [x] Command outputs summary: created/skipped items

---

# Plan: Implement `tuna init` command

## Overview

This plan describes the implementation steps for the `init` command that creates a directory structure for a new Assistant. The stub command already exists in `internal/command/init.go` and needs to be extended with actual functionality.

## Prerequisites

- Existing stub command in `internal/command/init.go`
- Standard library packages: `os`, `path/filepath`, `strings`, `fmt`

## Steps

### 1. Create validation package

**File:** `internal/assistant/validate.go`

Create a new package for assistant-related functionality, starting with ID validation:

```go
package assistant

import (
    "errors"
    "strings"
)

var (
    ErrEmptyID        = errors.New("assistant ID cannot be empty")
    ErrInvalidChars   = errors.New("assistant ID contains invalid characters")
    ErrReservedName   = errors.New("assistant ID cannot be '.' or '..'")
    ErrTooLong        = errors.New("assistant ID exceeds 255 characters")
)

// invalidChars contains characters not allowed in directory names
var invalidChars = []rune{'/', '\\', ':', '*', '?', '"', '<', '>', '|'}

// ValidateID checks if the given ID is a valid directory name.
func ValidateID(id string) error {
    if id == "" {
        return ErrEmptyID
    }
    if id == "." || id == ".." {
        return ErrReservedName
    }
    if len(id) > 255 {
        return ErrTooLong
    }
    for _, char := range invalidChars {
        if strings.ContainsRune(id, char) {
            return ErrInvalidChars
        }
    }
    return nil
}
```

### 2. Create initialization logic

**File:** `internal/assistant/init.go`

```go
package assistant

import (
    "fmt"
    "os"
    "path/filepath"
)

// InitResult contains the result of initialization.
type InitResult struct {
    Created []string
    Skipped []string
}

// Template files content
const (
    ExampleQueryContent = `# Example Query

Write your user query here.
`
    Fragment001Content = `# Fragment 001

Write your system prompt fragment here.
`
)

// Init creates the directory structure for a new assistant.
func Init(baseDir, assistantID string) (*InitResult, error) {
    if err := ValidateID(assistantID); err != nil {
        return nil, fmt.Errorf("invalid assistant ID: %w", err)
    }

    result := &InitResult{}
    root := filepath.Join(baseDir, assistantID)

    // Define structure
    dirs := []string{
        filepath.Join(root, "Input"),
        filepath.Join(root, "Output"),
        filepath.Join(root, "System prompt"),
    }

    files := []struct {
        path    string
        content string
        dir     string // parent dir to check if empty
    }{
        {filepath.Join(root, "Input", "example_query.md"), ExampleQueryContent, filepath.Join(root, "Input")},
        {filepath.Join(root, "Output", ".gitkeep"), "", filepath.Join(root, "Output")},
        {filepath.Join(root, "System prompt", "fragment_001.md"), Fragment001Content, filepath.Join(root, "System prompt")},
    }

    // Create directories
    for _, dir := range dirs {
        if err := createDir(dir, result); err != nil {
            return nil, err
        }
    }

    // Create files (only if directory is empty or file doesn't exist)
    for _, f := range files {
        if err := createFile(f.path, f.content, f.dir, result); err != nil {
            return nil, err
        }
    }

    return result, nil
}

func createDir(path string, result *InitResult) error {
    if _, err := os.Stat(path); os.IsNotExist(err) {
        if err := os.MkdirAll(path, 0755); err != nil {
            return fmt.Errorf("failed to create directory %s: %w", path, err)
        }
        result.Created = append(result.Created, path)
    } else if err != nil {
        return fmt.Errorf("failed to check directory %s: %w", path, err)
    } else {
        result.Skipped = append(result.Skipped, path)
    }
    return nil
}

func createFile(path, content, parentDir string, result *InitResult) error {
    // Skip if file already exists
    if _, err := os.Stat(path); err == nil {
        result.Skipped = append(result.Skipped, path)
        return nil
    }

    // Check if parent directory is empty (skip template if not empty)
    entries, err := os.ReadDir(parentDir)
    if err != nil {
        return fmt.Errorf("failed to read directory %s: %w", parentDir, err)
    }
    if len(entries) > 0 {
        result.Skipped = append(result.Skipped, path+" (directory not empty)")
        return nil
    }

    // Create the file
    if err := os.WriteFile(path, []byte(content), 0644); err != nil {
        return fmt.Errorf("failed to create file %s: %w", path, err)
    }
    result.Created = append(result.Created, path)
    return nil
}
```

### 3. Update init command

**File:** `internal/command/init.go`

```go
package command

import (
    "fmt"
    "os"

    "github.com/spf13/cobra"

    "go.octolab.org/tuna/internal/assistant"
)

// Init returns a cobra.Command to initialize project structure for a new assistant.
func Init() *cobra.Command {
    command := cobra.Command{
        Use:   "init <AssistantID>",
        Short: "Initialize project structure for a new assistant",
        Long: `Initialize creates the directory structure for a new assistant:

  AssistantID/
  ├── Input/           # User query files
  │   └── example_query.md
  ├── Output/          # Generated responses
  │   └── .gitkeep
  └── System prompt/   # System prompt fragments
      └── fragment_001.md

If the directory already exists, missing parts will be completed.
Existing files will not be overwritten.`,

        Args: cobra.ExactArgs(1),
        RunE: func(cmd *cobra.Command, args []string) error {
            assistantID := args[0]

            // Get current working directory
            cwd, err := os.Getwd()
            if err != nil {
                return fmt.Errorf("failed to get working directory: %w", err)
            }

            result, err := assistant.Init(cwd, assistantID)
            if err != nil {
                return err
            }

            // Print summary
            if len(result.Created) > 0 {
                cmd.Println("Created:")
                for _, item := range result.Created {
                    cmd.Printf("  + %s\n", item)
                }
            }

            if len(result.Skipped) > 0 {
                cmd.Println("Skipped (already exists):")
                for _, item := range result.Skipped {
                    cmd.Printf("  - %s\n", item)
                }
            }

            if len(result.Created) == 0 && len(result.Skipped) > 0 {
                cmd.Println("\nAssistant structure already complete.")
            } else {
                cmd.Printf("\nAssistant '%s' initialized successfully.\n", assistantID)
            }

            return nil
        },
    }

    return &command
}
```

### 4. Add unit tests for validation

**File:** `internal/assistant/validate_test.go`

```go
package assistant

import "testing"

func TestValidateID(t *testing.T) {
    tests := []struct {
        name    string
        id      string
        wantErr error
    }{
        {"valid simple", "my-assistant", nil},
        {"valid with spaces", "My Assistant", nil},
        {"valid with numbers", "assistant123", nil},
        {"empty", "", ErrEmptyID},
        {"dot", ".", ErrReservedName},
        {"double dot", "..", ErrReservedName},
        {"contains slash", "foo/bar", ErrInvalidChars},
        {"contains backslash", "foo\\bar", ErrInvalidChars},
        {"contains colon", "foo:bar", ErrInvalidChars},
        {"contains asterisk", "foo*bar", ErrInvalidChars},
        {"contains question mark", "foo?bar", ErrInvalidChars},
        {"contains quote", "foo\"bar", ErrInvalidChars},
        {"contains less than", "foo<bar", ErrInvalidChars},
        {"contains greater than", "foo>bar", ErrInvalidChars},
        {"contains pipe", "foo|bar", ErrInvalidChars},
        {"too long", string(make([]byte, 256)), ErrTooLong},
        {"max length", string(make([]byte, 255)), nil},
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            err := ValidateID(tt.id)
            if err != tt.wantErr {
                t.Errorf("ValidateID(%q) = %v, want %v", tt.id, err, tt.wantErr)
            }
        })
    }
}
```

### 5. Add unit tests for initialization

**File:** `internal/assistant/init_test.go`

```go
package assistant

import (
    "os"
    "path/filepath"
    "testing"
)

func TestInit(t *testing.T) {
    t.Run("creates full structure", func(t *testing.T) {
        tmpDir := t.TempDir()

        result, err := Init(tmpDir, "test-assistant")
        if err != nil {
            t.Fatalf("Init() error = %v", err)
        }

        // Check directories created
        expectedDirs := []string{"Input", "Output", "System prompt"}
        for _, dir := range expectedDirs {
            path := filepath.Join(tmpDir, "test-assistant", dir)
            if _, err := os.Stat(path); os.IsNotExist(err) {
                t.Errorf("Directory %s was not created", dir)
            }
        }

        // Check files created
        expectedFiles := []string{
            filepath.Join("Input", "example_query.md"),
            filepath.Join("Output", ".gitkeep"),
            filepath.Join("System prompt", "fragment_001.md"),
        }
        for _, file := range expectedFiles {
            path := filepath.Join(tmpDir, "test-assistant", file)
            if _, err := os.Stat(path); os.IsNotExist(err) {
                t.Errorf("File %s was not created", file)
            }
        }

        if len(result.Created) != 6 { // 3 dirs + 3 files
            t.Errorf("Expected 6 created items, got %d", len(result.Created))
        }
    })

    t.Run("completes partial structure", func(t *testing.T) {
        tmpDir := t.TempDir()

        // Create partial structure
        os.MkdirAll(filepath.Join(tmpDir, "partial", "Input"), 0755)

        result, err := Init(tmpDir, "partial")
        if err != nil {
            t.Fatalf("Init() error = %v", err)
        }

        // Input should be skipped (exists)
        // Output and System prompt should be created
        if len(result.Skipped) < 1 {
            t.Error("Expected at least 1 skipped item")
        }
    })

    t.Run("skips existing files", func(t *testing.T) {
        tmpDir := t.TempDir()

        // Create full structure with custom file
        inputDir := filepath.Join(tmpDir, "existing", "Input")
        os.MkdirAll(inputDir, 0755)
        os.WriteFile(filepath.Join(inputDir, "custom.md"), []byte("custom"), 0644)

        result, err := Init(tmpDir, "existing")
        if err != nil {
            t.Fatalf("Init() error = %v", err)
        }

        // example_query.md should be skipped because Input is not empty
        found := false
        for _, item := range result.Skipped {
            if filepath.Base(item) == "example_query.md" ||
               (len(item) > 20 && item[len(item)-20:] == "(directory not empty)") {
                found = true
                break
            }
        }
        if !found {
            t.Error("Expected example_query.md to be skipped")
        }
    })

    t.Run("rejects invalid ID", func(t *testing.T) {
        tmpDir := t.TempDir()

        _, err := Init(tmpDir, "invalid/name")
        if err == nil {
            t.Error("Expected error for invalid ID")
        }
    })
}
```

### 6. Verify implementation

- [x] Run `go build` to ensure no compilation errors
- [x] Run `go test ./internal/assistant/...` to verify unit tests pass
- [x] Run `tuna init test-assistant` in a temp directory
- [x] Verify directory structure is created correctly
- [x] Run `tuna init test-assistant` again to verify idempotent behavior
- [x] Test with invalid IDs: empty, `.`, `..`, `foo/bar`
- [x] Test partial structure completion

## File Changes Summary

| File                                       | Action |
|--------------------------------------------|--------|
| `internal/assistant/validate.go`           | Create |
| `internal/assistant/validate_test.go`      | Create |
| `internal/assistant/init.go`               | Create |
| `internal/assistant/init_test.go`          | Create |
| `internal/command/init.go`                 | Modify |

## Notes

- The `assistant` package is created to encapsulate all assistant-related logic
- Validation is separated into its own file for reuse in `plan` command
- Template content is defined as constants for easy modification
- Error messages are user-friendly and actionable
- The command uses `RunE` instead of `Run` to properly propagate errors
