---
issue: 51
status: closed
type: task
labels:
  - "effort: easy"
  - "impact: low"
  - "scope: code"
  - "type: improvement"
assignees:
  - kamilsk
milestone: null
projects: []
relationships:
  parent: null
  blocked_by: []
  blocks: []
---

# Add Stub Commands for CLI Interface

## Summary

Implement stub commands (`init`, `plan`, `exec`) that match the CLI interface defined in the specification. These commands should be functional skeletons that accept all specified flags and arguments but only print placeholder messages.

## Background

Currently, the project only has demo commands (`panic`, `stderr`, `stdout`). We need to scaffold the main CLI commands before implementing the actual logic.

## Requirements

### Commands to implement

#### `tuna init <AssistantID>`
- **Purpose**: Initialize project structure for a new assistant
- **Arguments**: `AssistantID` (required) - name of the assistant directory to create
- **Stub behavior**: Print message like `"Initializing assistant: {AssistantID}..."`

#### `tuna plan <AssistantID> [flags]`
- **Purpose**: Create an execution plan
- **Arguments**: `AssistantID` (required)
- **Flags**:
  | Flag            | Short | Type   | Default                    | Description                   |
  |-----------------|-------|--------|----------------------------|-------------------------------|
  | `--models`      | `-m`  | string | `claude-sonnet-4-20250514` | Comma-separated list of models |
  | `--temperature` |       | float  | `0.7`                      | Temperature setting           |
  | `--max-tokens`  |       | int    | `4096`                     | Max tokens for response       |
- **Stub behavior**: Print received arguments and flag values

#### `tuna exec <PlanID> [flags]`
- **Purpose**: Execute a plan
- **Arguments**: `PlanID` (required)
- **Flags**:
  | Flag         | Short | Type | Default | Description                                          |
  |--------------|-------|------|---------|------------------------------------------------------|
  | `--parallel` | `-p`  | int  | `1`     | Number of parallel requests                          |
  | `--dry-run`  |       | bool | `false` | Show what would be executed without making API calls |
  | `--continue` |       | bool | `false` | Continue from last checkpoint if interrupted         |
- **Stub behavior**: Print received arguments and flag values

## Implementation Notes

1. Create new files under `internal/command/`:
   - `init.go`
   - `plan.go`
   - `exec.go`

2. Register commands in `root.go`

3. Follow existing code style from `demo/` commands

4. Update root command metadata:
   - `Use`: `tuna`
   - `Short`: `Prompt engineering automation tool`
   - `Long`: Descriptive help text

## Acceptance Criteria

- [x] All three commands are registered and visible in `tuna --help`
- [x] Each command accepts its specified arguments and flags
- [x] Running a command prints its received configuration
- [x] `tuna <cmd> --help` shows proper usage with all flags documented
- [x] Code follows existing project conventions

---

# Plan: Add Stub Commands for CLI Interface

## Overview

This plan describes the implementation steps for adding stub commands (`init`, `plan`, `exec`) to the tuna CLI.

## Prerequisites

- Existing demo commands in `internal/command/demo/` as reference
- Cobra library for CLI structure

## Steps

### 1. Update root command metadata

**File:** `internal/command/root.go`

- Change `Use` from `%template%` to `tuna`
- Change `Short` to `Prompt engineering automation tool`
- Change `Long` to descriptive help text

### 2. Create `init` command

**File:** `internal/command/init.go`

```go
func Init() *cobra.Command {
    command := cobra.Command{
        Use:   "init <AssistantID>",
        Short: "Initialize project structure for a new assistant",
        Args:  cobra.ExactArgs(1),
        Run: func(cmd *cobra.Command, args []string) {
            cmd.Printf("Initializing assistant: %s...\n", args[0])
        },
    }
    return &command
}
```

### 3. Create `plan` command

**File:** `internal/command/plan.go`

```go
func Plan() *cobra.Command {
    var (
        models      string
        temperature float64
        maxTokens   int
    )

    command := cobra.Command{
        Use:   "plan <AssistantID>",
        Short: "Create an execution plan",
        Args:  cobra.ExactArgs(1),
        Run: func(cmd *cobra.Command, args []string) {
            cmd.Printf("Creating plan for assistant: %s\n", args[0])
            cmd.Printf("  Models:      %s\n", models)
            cmd.Printf("  Temperature: %.1f\n", temperature)
            cmd.Printf("  Max tokens:  %d\n", maxTokens)
        },
    }

    command.Flags().StringVarP(&models, "models", "m", "claude-sonnet-4-20250514", "Comma-separated list of models")
    command.Flags().Float64Var(&temperature, "temperature", 0.7, "Temperature setting")
    command.Flags().IntVar(&maxTokens, "max-tokens", 4096, "Max tokens for response")

    return &command
}
```

### 4. Create `exec` command

**File:** `internal/command/exec.go`

```go
func Exec() *cobra.Command {
    var (
        parallel   int
        dryRun     bool
        continueOp bool
    )

    command := cobra.Command{
        Use:   "exec <PlanID>",
        Short: "Execute a plan",
        Args:  cobra.ExactArgs(1),
        Run: func(cmd *cobra.Command, args []string) {
            cmd.Printf("Executing plan: %s\n", args[0])
            cmd.Printf("  Parallel: %d\n", parallel)
            cmd.Printf("  Dry run:  %t\n", dryRun)
            cmd.Printf("  Continue: %t\n", continueOp)
        },
    }

    command.Flags().IntVarP(&parallel, "parallel", "p", 1, "Number of parallel requests")
    command.Flags().BoolVar(&dryRun, "dry-run", false, "Show what would be executed without making API calls")
    command.Flags().BoolVar(&continueOp, "continue", false, "Continue from last checkpoint if interrupted")

    return &command
}
```

### 5. Register commands in root.go

**File:** `internal/command/root.go`

```go
command.AddCommand(
    Init(),
    Plan(),
    Exec(),
)
```

### 6. Remove demo commands

**Files to delete:**
- `internal/command/demo/` (entire directory)

**File to modify:** `internal/command/root.go`
- Remove import `"go.octolab.org/toolset/tuna/internal/command/demo"`
- Remove `demo.Panic()`, `demo.Stderr()`, `demo.Stdout()` from `AddCommand()`

### 7. Verify implementation

- [x] Run `go build` to ensure no compilation errors
- [x] Run `tuna --help` to verify all commands are visible
- [x] Run `tuna init --help` to verify help text
- [x] Run `tuna plan --help` to verify flags documentation
- [x] Run `tuna exec --help` to verify flags documentation
- [x] Run `tuna init test-assistant` to verify stub output
- [x] Run `tuna plan test-assistant -m gpt-4` to verify flag parsing
- [x] Run `tuna exec plan-123 --dry-run` to verify flag parsing

## File Changes Summary

| File                         | Action |
|------------------------------|--------|
| `internal/command/root.go`   | Modify |
| `internal/command/init.go`   | Create |
| `internal/command/plan.go`   | Create |
| `internal/command/exec.go`   | Create |
| `internal/command/demo/`     | Delete |

## Notes

- Use `cobra.ExactArgs(1)` to enforce required positional argument
- Follow existing code style: function returns `*cobra.Command`
